{
  "metadata": {
    "created": "2025-07-12T00:00:00.000Z",
    "updated": "2025-07-12T00:00:00.000Z",
    "version": "1.0.0",
    "featureName": "missing-types-implementation"
  },
  "contextAnalysis": {
    "problemDefinition": "ScalaSchemaz (Chez) has excellent core JSON Schema derivation capabilities but is missing support for critical Scala collection types (Map, Set, Vector), enum support, sealed traits, union types, and has broken default value handling, preventing production adoption and limiting real-world usage scenarios.",
    "technicalApproach": "scala/mill build system with Scala 3.6.2",
    "codebasePatterns": "Scala 3 Mirror-based derivation system with given instances, upickle JSON handling, utest framework",
    "externalDocs": "ScalaSchemaz JSON Schema library with annotation-based derivation"
  },
  "tasks": [
    {
      "id": "T1",
      "title": "Fix Default Value Handling in Schema Derivation",
      "description": "Fix the broken default value detection so fields with @Schema.default annotations and Scala case class defaults are not marked as required in generated schemas",
      "priority": "P0",
      "status": "pending",
      "estimatedHours": 3,
      "userStory": "As a backend API developer, I want default values to not be marked as required so that my API clients can omit optional fields with defaults",
      "contextAnalysis": {
        "whatExists": ["getRequiredFields function in SchemaDerivation.scala", "AnnotationProcessor for @Schema.default", "Mirror.ProductOf[T] derivation"],
        "whatsMissing": ["Default value detection logic", "Integration between annotation defaults and Scala case class defaults", "Required field filtering based on defaults"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "functions": ["getRequiredFields", "deriveProductWithAnnotations", "new: hasDefaultValue"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Enhance getRequiredFields[Elems <: Tuple] to check for @Schema.default annotations via AnnotationProcessor and detect Scala case class parameter defaults using compile-time reflection. Fields should not be marked required if they have either annotation defaults or Scala defaults.",
      "implementationConstraints": ["Must maintain compile-time-only derivation", "Cannot use runtime reflection", "Must not break existing Schema[T] derivations", "Must preserve backward compatibility"],
      "externalDependencies": [],
      "integrationPoints": ["AnnotationProcessor.extractAllFieldAnnotations", "Mirror.ProductOf[T] parameter introspection", "ObjectChez required field generation"],
      "acceptanceCriteria": [
        "Case class with @Schema.default annotations does not mark those fields as required",
        "Case class with Scala default parameters (field: Type = defaultValue) does not mark those fields as required", 
        "Mixed scenarios with optional, required, and default fields work correctly",
        "DefaultAnnotationTests pass with new test cases"
      ],
      "successDefinition": "All 4 failing default value tests pass, generated schemas correctly identify required vs optional vs default fields",
      "outOfScope": ["New validation features", "Complex default value serialization", "Runtime default value handling"],
      "dependencies": [],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T2", 
      "title": "Fix Examples Serialization in Array and Object Schemas",
      "description": "Fix the broken examples serialization in ArrayChez and ObjectChez toJsonSchema methods to properly handle ujson.Value arrays",
      "priority": "P0",
      "status": "pending", 
      "estimatedHours": 2,
      "userStory": "As a library maintainer, I want examples to serialize correctly so that generated JSON schemas include proper example values",
      "contextAnalysis": {
        "whatExists": ["ArrayChez.toJsonSchema method", "ObjectChez.toJsonSchema method", "examples field in base Chez trait"],
        "whatsMissing": ["Proper ujson.Value array serialization", "Examples handling in withExamples calls"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/complex/ArrayChez.scala", "Chez/src/main/scala/chez/complex/ObjectChez.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/complex/ArrayChez.scala", "Chez/src/main/scala/chez/complex/ObjectChez.scala"],
        "functions": ["toJsonSchema in ArrayChez", "toJsonSchema in ObjectChez"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Fix examples field serialization in toJsonSchema methods to properly convert List[ujson.Value] to ujson.Arr. Ensure withExamples() method calls work correctly across test files.",
      "implementationConstraints": ["Must maintain JSON Schema 2020-12 compliance", "Cannot break existing API", "Must work with upickle ujson.Value types"],
      "externalDependencies": ["upickle ujson"],
      "integrationPoints": ["Base Chez trait examples field", "withExamples modifier method", "JSON Schema output generation"],
      "acceptanceCriteria": [
        "ArrayChez examples serialize as valid JSON array",
        "ObjectChez examples serialize as valid JSON array", 
        "withExamples() calls in test files work without errors",
        "ArrayChezTests examples serialization tests pass"
      ],
      "successDefinition": "Examples field properly serializes in JSON Schema output for arrays and objects",
      "outOfScope": ["New example validation features", "Example value validation", "Complex example structures"],
      "dependencies": [],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T3",
      "title": "Implement Map[K,V] Schema Derivation Support",
      "description": "Create given Schema instances for Map[K,V] types that generate ObjectChez with additionalProperties for Map[String,V] and patternProperties for other key types",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 4,
      "userStory": "As a backend API developer, I want to use Map[String, User] in my API models so that I can represent key-value relationships in JSON Schema",
      "contextAnalysis": {
        "whatExists": ["Schema derivation system with given instances", "ObjectChez with additionalProperties and patternProperties support", "Existing given instances for primitives and List"],
        "whatsMissing": ["given instance for Map[K,V]", "Logic to handle different key types", "Tests for Map derivation"]
      },
      "fileStructureChanges": {
        "newFiles": ["Chez/src/main/scala/chez/derivation/CollectionSchemas.scala"],
        "modifiedFiles": [],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/CollectionSchemas.scala"],
        "functions": ["given [K, V](using kSchema: Schema[K], vSchema: Schema[V]): Schema[Map[K, V]]"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Implement given instance: Map[String, V] maps to ObjectChez(additionalProperties = Some(V.schema)), Map[K, V] where K != String maps to ObjectChez(patternProperties = Map('.*' -> V.schema), description = Some('Map with K keys')). Use type-level checks to determine key type.",
      "implementationConstraints": ["Must integrate with existing Schema derivation system", "Cannot break existing ObjectChez functionality", "Must handle generic type parameters correctly"],
      "externalDependencies": [],
      "integrationPoints": ["Schema[T] derivation system", "ObjectChez constructor", "Type-level programming for key type detection"],
      "acceptanceCriteria": [
        "Map[String, Int] generates ObjectChez with additionalProperties",
        "Map[Int, String] generates ObjectChez with patternProperties",
        "Nested maps work correctly (Map[String, Map[String, Int]])",
        "Map derivation integrates with case class derivation"
      ],
      "successDefinition": "Map types can be used in case classes and generate proper JSON Schema object representations",
      "outOfScope": ["Runtime Map validation", "Map key validation beyond JSON Schema capabilities", "Complex Map serialization"],
      "dependencies": ["T1", "T2"],
      "createdDate": "2025-07-12T00:00:00.000Z", 
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T4",
      "title": "Implement Set[T] Schema Derivation Support", 
      "description": "Create given Schema instance for Set[T] types that generate ArrayChez with uniqueItems=true to enforce set semantics in JSON Schema",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 2,
      "userStory": "As a backend API developer, I want to use Set[String] in my data models so that I can enforce uniqueness constraints in JSON Schema",
      "contextAnalysis": {
        "whatExists": ["ArrayChez with uniqueItems support", "Schema derivation for List[T]", "given instance pattern"],
        "whatsMissing": ["given instance for Set[T]", "Tests for Set derivation"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/derivation/CollectionSchemas.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/CollectionSchemas.scala"],
        "functions": ["given [T](using tSchema: Schema[T]): Schema[Set[T]]"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Implement given instance: Set[T] maps to ArrayChez(T.schema, uniqueItems = Some(true)). Follow same pattern as existing List[T] derivation but with uniqueItems constraint.",
      "implementationConstraints": ["Must reuse existing ArrayChez", "Cannot break List[T] derivation", "Must integrate with case class derivation"],
      "externalDependencies": [],
      "integrationPoints": ["ArrayChez constructor", "Schema[T] type parameter", "Case class field derivation"],
      "acceptanceCriteria": [
        "Set[String] generates ArrayChez with uniqueItems=true",
        "Set[Int] generates proper integer array schema",
        "Nested sets work (Set[Set[String]])",
        "Set used in case class field works correctly"
      ],
      "successDefinition": "Set types generate JSON Schema arrays with uniqueItems constraint",
      "outOfScope": ["Runtime set validation", "Set ordering preservation", "Complex set operations"],
      "dependencies": ["T3"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T5",
      "title": "Implement Vector[T] Schema Derivation Support",
      "description": "Create given Schema instance for Vector[T] types that generate ArrayChez identical to List[T] for immutable collection support",
      "priority": "P1", 
      "status": "pending",
      "estimatedHours": 1,
      "userStory": "As an enterprise developer, I want Vector support so that I can use immutable collections without losing schema generation",
      "contextAnalysis": {
        "whatExists": ["List[T] derivation with ArrayChez", "Schema given instance pattern", "ArrayChez implementation"],
        "whatsMissing": ["given instance for Vector[T]"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/derivation/CollectionSchemas.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/CollectionSchemas.scala"],
        "functions": ["given [T](using tSchema: Schema[T]): Schema[Vector[T]]"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Implement given instance: Vector[T] maps to ArrayChez(T.schema) - identical to List[T] implementation. Vector and List should generate identical JSON Schema.",
      "implementationConstraints": ["Must be identical to List[T] behavior", "Cannot break existing array derivation"],
      "externalDependencies": [],
      "integrationPoints": ["ArrayChez constructor", "Existing List[T] derivation pattern"],
      "acceptanceCriteria": [
        "Vector[String] generates same schema as List[String]",
        "Vector[Int] works correctly",
        "Vector used in case class compiles and generates proper schema"
      ],
      "successDefinition": "Vector types work identically to List types in schema generation",
      "outOfScope": ["Vector-specific optimizations", "Performance differences from List"],
      "dependencies": ["T4"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T6",
      "title": "Fix Scala 3 Enum Schema Derivation",
      "description": "Fix the broken enum derivation in deriveSumWithAnnotations to properly handle Scala 3 enums using Mirror.SumOf and generate StringChez with enumValues",
      "priority": "P0",
      "status": "pending",
      "estimatedHours": 4,
      "userStory": "As a backend developer, I want enum derivation to work without compilation errors so that I can use type-safe status codes in my APIs",
      "contextAnalysis": {
        "whatExists": ["Mirror.SumOf[T] derivation in deriveSumWithAnnotations", "StringChez with enumValues support", "Compile-time reflection capabilities"],
        "whatsMissing": ["Proper enum case name extraction", "Enum vs sealed trait differentiation", "StringChez enumValues generation"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "functions": ["deriveSumWithAnnotations", "new: isEnumType", "new: extractEnumCaseNames"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Enhance deriveSumWithAnnotations to detect enum types vs sealed traits using Mirror.SumOf. For enums, extract case names at compile-time and generate StringChez(enumValues = Some(caseNames)). Use constValue and compiletime reflection to get enum case names.",
      "implementationConstraints": ["Must maintain compile-time-only derivation", "Cannot break sealed trait derivation", "Must work with Scala 3 enum syntax"],
      "externalDependencies": [],
      "integrationPoints": ["Mirror.SumOf[T] type inspection", "StringChez enumValues field", "Compile-time case name extraction"],
      "acceptanceCriteria": [
        "Simple Scala 3 enum compiles without errors",
        "Enum generates StringChez with correct enumValues",
        "Enum derivation works in case class fields", 
        "Does not break existing sealed trait derivation"
      ],
      "successDefinition": "Scala 3 enums compile successfully and generate proper string enum JSON Schema",
      "outOfScope": ["Enum with associated values", "Complex enum patterns", "Runtime enum validation"],
      "dependencies": ["T1", "T2"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T7",
      "title": "Implement Sealed Trait Discriminated Union Support",
      "description": "Enhance deriveSumWithAnnotations to generate discriminated unions using OneOfChez for sealed trait hierarchies with automatic type discriminator injection",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 4,
      "userStory": "As an enterprise developer, I want sealed trait support so that I can model complex domain hierarchies with type safety",
      "contextAnalysis": {
        "whatExists": ["OneOfChez composition support", "Mirror.SumOf[T] derivation", "Case class derivation with const annotations"],
        "whatsMissing": ["Discriminated union generation", "Type field injection", "Sealed trait vs enum differentiation"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "functions": ["deriveSumWithAnnotations", "new: deriveSealedTrait", "new: addDiscriminatorField"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "For sealed traits with case classes, generate OneOfChez where each case class gets enhanced with a 'type' field containing const value of the class name. Use Mirror.SumOf to iterate case classes and enhance their ObjectChez representations.",
      "implementationConstraints": ["Must not break enum derivation from T6", "Must preserve existing case class derivation", "Cannot modify user-defined case classes"],
      "externalDependencies": [],
      "integrationPoints": ["OneOfChez constructor", "ObjectChez property enhancement", "Mirror.SumOf case iteration"],
      "acceptanceCriteria": [
        "Sealed trait with case classes generates OneOfChez",
        "Each case class gets discriminator 'type' field",
        "Discriminator values match case class names",
        "Nested sealed traits work correctly"
      ],
      "successDefinition": "Sealed traits generate discriminated union JSON Schema with proper type discrimination",
      "outOfScope": ["Custom discriminator field names", "Multiple discriminator strategies", "Deep inheritance hierarchies"],
      "dependencies": ["T6"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T8",
      "title": "Implement Either[A,B] Union Type Support",
      "description": "Create given Schema instance for Either[A,B] types that generate AnyOfChez composition representing success/error or alternative value patterns",
      "priority": "P2",
      "status": "pending",
      "estimatedHours": 3,
      "userStory": "As an enterprise developer, I want Either[A,B] support so that I can represent error/success patterns in my API schemas",
      "contextAnalysis": {
        "whatExists": ["AnyOfChez composition support", "Schema derivation system", "Error handling patterns in existing code"],
        "whatsMissing": ["given instance for Either[A,B]", "Union type file organization"]
      },
      "fileStructureChanges": {
        "newFiles": ["Chez/src/main/scala/chez/derivation/UnionTypeSchemas.scala"],
        "modifiedFiles": [],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/UnionTypeSchemas.scala"],
        "functions": ["given [A, B](using aSchema: Schema[A], bSchema: Schema[B]): Schema[Either[A, B]]"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Implement given instance: Either[A, B] maps to AnyOfChez(List(A.schema, B.schema)). Create new file UnionTypeSchemas.scala to organize union type derivations separately from collections.",
      "implementationConstraints": ["Must integrate with existing AnyOfChez", "Cannot break case class derivation", "Must handle nested Either types"],
      "externalDependencies": [],
      "integrationPoints": ["AnyOfChez constructor", "Schema type parameter resolution", "Either left/right type handling"],
      "acceptanceCriteria": [
        "Either[String, Int] generates AnyOfChez with both schemas",
        "Either[Error, Success] works with custom types",
        "Nested Either types compile correctly",
        "Either used in case class fields works"
      ],
      "successDefinition": "Either types generate union JSON Schema allowing either left or right value",
      "outOfScope": ["Either serialization semantics", "Left/Right discrimination in JSON", "Either validation logic"],
      "dependencies": ["T7"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T9",
      "title": "Create Comprehensive Collection Type Tests",
      "description": "Create comprehensive test suite for Map, Set, Vector derivation covering basic usage, nested scenarios, and integration with case class derivation",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 3,
      "userStory": "As a library maintainer, I want comprehensive tests for collection types so that I can ensure reliability and catch regressions",
      "contextAnalysis": {
        "whatExists": ["utest framework", "Existing derivation tests pattern in SchemaDerivationTests", "ArrayChezTests and ObjectChezTests patterns"],
        "whatsMissing": ["Collection-specific test file", "Map/Set/Vector test scenarios", "Integration tests"]
      },
      "fileStructureChanges": {
        "newFiles": ["Chez/test/src/chez/derivation/CollectionDerivationTests.scala"],
        "modifiedFiles": [],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/test/src/chez/derivation/CollectionDerivationTests.scala"],
        "functions": ["Map derivation tests", "Set derivation tests", "Vector derivation tests", "nested collection tests", "case class integration tests"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Create utest test suite following existing patterns. Test: Map[String, Int], Map[Int, String], Set[String], Vector[Int], nested collections (Map[String, Set[Int]]), case classes with collection fields, JSON schema output validation.",
      "implementationConstraints": ["Must follow existing test patterns", "Must use utest framework", "Must validate JSON schema output"],
      "externalDependencies": ["utest"],
      "integrationPoints": ["Schema derivation system", "JSON schema validation", "Existing test utilities"],
      "acceptanceCriteria": [
        "All Map derivation scenarios pass",
        "All Set derivation scenarios pass",
        "All Vector derivation scenarios pass",
        "Nested collection tests pass",
        "Case class integration tests pass",
        "JSON schema output matches expected format"
      ],
      "successDefinition": "Comprehensive test coverage for collection types with all tests passing",
      "outOfScope": ["Performance testing", "Memory usage testing", "Edge case error handling"],
      "dependencies": ["T3", "T4", "T5"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T10",
      "title": "Create Enum and Sealed Trait Derivation Tests",
      "description": "Create comprehensive test suite for enum and sealed trait derivation covering simple enums, sealed trait hierarchies, and discriminated union patterns",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 3,
      "userStory": "As a library maintainer, I want comprehensive tests for ADT types so that enum and sealed trait derivation is reliable",
      "contextAnalysis": {
        "whatExists": ["utest framework", "Existing derivation test patterns", "Enum and sealed trait examples in existing code"],
        "whatsMissing": ["Dedicated enum test file", "Sealed trait test file", "Discriminated union validation"]
      },
      "fileStructureChanges": {
        "newFiles": ["Chez/test/src/chez/derivation/EnumDerivationTests.scala"],
        "modifiedFiles": [],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/test/src/chez/derivation/EnumDerivationTests.scala"],
        "functions": ["enum derivation tests", "sealed trait tests", "discriminated union tests", "nested ADT tests"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Create utest test suite for: simple Scala 3 enums generating StringChez with enumValues, sealed traits generating OneOfChez with discriminator, case classes in sealed trait hierarchy, nested enum/sealed trait scenarios, JSON schema validation.",
      "implementationConstraints": ["Must follow existing test patterns", "Must validate discriminator fields", "Must check enumValues arrays"],
      "externalDependencies": ["utest"],
      "integrationPoints": ["Enum derivation from T6", "Sealed trait derivation from T7", "JSON schema output validation"],
      "acceptanceCriteria": [
        "Simple enum tests pass",
        "Sealed trait discriminated union tests pass", 
        "Enum JSON schema contains correct enumValues",
        "Sealed trait JSON schema contains discriminator",
        "Nested ADT scenarios work correctly"
      ],
      "successDefinition": "Comprehensive test coverage for enum and sealed trait derivation with all tests passing",
      "outOfScope": ["Complex enum patterns", "Deep inheritance testing", "Performance validation"],
      "dependencies": ["T6", "T7"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T11",
      "title": "Create Union Type Derivation Tests",
      "description": "Create test suite for Either[A,B] and other union type derivation covering basic Either usage and integration scenarios",
      "priority": "P2",
      "status": "pending",
      "estimatedHours": 2,
      "userStory": "As a library maintainer, I want tests for union types so that Either derivation is reliable and catches regressions",
      "contextAnalysis": {
        "whatExists": ["utest framework", "Either derivation from T8", "AnyOfChez testing patterns"],
        "whatsMissing": ["Union type test file", "Either test scenarios"]
      },
      "fileStructureChanges": {
        "newFiles": ["Chez/test/src/chez/derivation/UnionTypeTests.scala"],
        "modifiedFiles": [],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/test/src/chez/derivation/UnionTypeTests.scala"],
        "functions": ["Either[A,B] derivation tests", "nested Either tests", "case class integration tests"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Create utest test suite for: Either[String, Int], Either[CustomType, Error], nested Either scenarios, Either used in case class fields, AnyOfChez JSON schema validation.",
      "implementationConstraints": ["Must follow existing test patterns", "Must validate AnyOfChez output"],
      "externalDependencies": ["utest"],
      "integrationPoints": ["Either derivation from T8", "AnyOfChez validation", "Case class derivation integration"],
      "acceptanceCriteria": [
        "Basic Either derivation tests pass",
        "Nested Either scenarios work",
        "Either in case class compiles and tests pass",
        "AnyOfChez JSON schema validates correctly"
      ],
      "successDefinition": "Comprehensive test coverage for union types with all tests passing",
      "outOfScope": ["Complex union patterns", "Either performance testing"],
      "dependencies": ["T8"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T12",
      "title": "Enhance Default Value Tests and Validation",
      "description": "Enhance existing DefaultAnnotationTests with comprehensive scenarios for mixed required/optional/default fields and edge cases",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 2,
      "userStory": "As a library maintainer, I want comprehensive default value tests so that the fixed default handling is thoroughly validated",
      "contextAnalysis": {
        "whatExists": ["DefaultAnnotationTests.scala", "Basic default value test scenarios", "AnnotationProcessor testing"],
        "whatsMissing": ["Mixed field scenario tests", "Edge case validation", "Scala default vs annotation default tests"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/test/src/chez/derivation/DefaultAnnotationTests.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/test/src/chez/derivation/DefaultAnnotationTests.scala"],
        "functions": ["enhanced test scenarios", "mixed field tests", "edge case validation"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Add test cases for: case classes with mix of required, optional (Option[T]), and default fields, both @Schema.default and Scala default parameters, complex default values, validation that required arrays do not include default fields.",
      "implementationConstraints": ["Must not break existing tests", "Must validate against fixed implementation from T1"],
      "externalDependencies": ["utest"],
      "integrationPoints": ["Fixed default value handling from T1", "AnnotationProcessor", "Schema derivation system"],
      "acceptanceCriteria": [
        "Mixed field scenario tests pass",
        "Both annotation and Scala defaults work correctly",
        "Required field arrays exclude default fields",
        "All original DefaultAnnotationTests continue to pass"
      ],
      "successDefinition": "Enhanced default value test coverage with all tests passing including new edge cases",
      "outOfScope": ["Complex default value types", "Runtime default validation"],
      "dependencies": ["T1"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T13",
      "title": "Validation and Integration Testing",
      "description": "Run comprehensive test suite to ensure 100% test pass rate (157/157) and validate all new type support integrates correctly with existing functionality",
      "priority": "P0",
      "status": "pending", 
      "estimatedHours": 2,
      "userStory": "As a library maintainer, I want all tests to pass so that I can confidently deploy to production",
      "contextAnalysis": {
        "whatExists": ["Full test suite with 157 tests", "Mill build system test runner", "Existing test infrastructure"],
        "whatsMissing": ["100% pass rate", "Integration validation", "Performance validation"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": [],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": [],
        "functions": [],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Run './mill Chez.test' to execute full test suite. Validate that all 157 tests pass. Run performance checks to ensure compilation times under 5 seconds. Validate backward compatibility with existing Schema[T] usage.",
      "implementationConstraints": ["All existing tests must continue to pass", "Cannot break existing API", "Performance must not degrade"],
      "externalDependencies": ["mill build system"],
      "integrationPoints": ["All implemented features T1-T12", "Existing Schema derivation system", "Full codebase integration"],
      "acceptanceCriteria": [
        "All 157 tests pass (100% pass rate)",
        "No compilation errors or warnings",
        "Complex type derivation completes in under 5 seconds",
        "Existing examples still work correctly",
        "No breaking changes to public API"
      ],
      "successDefinition": "100% test pass rate achieved with full functionality validation",
      "outOfScope": ["Performance optimization", "New feature development", "Documentation updates"],
      "dependencies": ["T1", "T2", "T6", "T9", "T10", "T12"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    },
    {
      "id": "T14",
      "title": "Implement Scala Case Class Default Parameter Detection",
      "description": "Complete the missing Scala case class default detection functionality in hasScalaDefaultValueImpl macro to properly identify fields with default parameters (field: Type = defaultValue)",
      "priority": "P1",
      "status": "pending",
      "estimatedHours": 4,
      "userStory": "As a backend API developer, I want case class fields with Scala defaults (field: String = 'default') to not be marked as required so that my API schemas reflect the true optionality of fields",
      "contextAnalysis": {
        "whatExists": ["hasScalaDefaultValueImpl macro stub in SchemaDerivation.scala", "getRequiredFieldsWithDefaults calling hasScalaDefaultValue", "Working @Schema.default annotation detection", "Knowledge of default method naming pattern ($lessinit$greater$default$N)"],
        "whatsMissing": ["Proper Scala 3 macro implementation for default detection", "Compile-time reflection to access companion object methods", "Integration with Mirror.ProductOf field indexing"]
      },
      "fileStructureChanges": {
        "newFiles": [],
        "modifiedFiles": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "movedFiles": []
      },
      "implementationDetails": {
        "files": ["Chez/src/main/scala/chez/derivation/SchemaDerivation.scala"],
        "functions": ["hasScalaDefaultValueImpl", "hasScalaDefaultValue (inline wrapper)"],
        "apiEndpoints": [],
        "databaseChanges": []
      },
      "technicalSpecifications": "Fix the hasScalaDefaultValueImpl macro to properly detect Scala case class default methods using Scala 3 quoted reflection. The macro should: 1) Access the companion object of type T, 2) Look for methods named $lessinit$greater$default$N where N is fieldIndex+1, 3) Return true if the method exists. Use proper Symbol inspection and handle edge cases like missing companion objects.",
      "implementationConstraints": ["Must maintain compile-time-only derivation", "Cannot use runtime reflection", "Must work with Scala 3 quoted reflection API", "Cannot break existing @Schema.default functionality", "Must handle missing companion objects gracefully"],
      "externalDependencies": ["scala.quoted", "scala.compiletime"],
      "integrationPoints": ["getRequiredFieldsWithDefaultsHelper function", "Mirror.ProductOf[T] field indexing", "Existing @Schema.default detection", "Case class companion object method inspection"],
      "acceptanceCriteria": [
        "Case class with Scala default parameters (field: Type = defaultValue) does not mark those fields as required",
        "SchemaDerivationTests 'case class with default values' test passes",
        "SchemaDerivationTests 'case class with complex default values' test passes for Scala defaults",
        "Mixed scenarios with @Schema.default and Scala defaults work correctly",
        "No compilation errors with complex case class hierarchies"
      ],
      "successDefinition": "All remaining SchemaDerivationTests involving Scala case class defaults pass, bringing the total test pass rate closer to 100%",
      "outOfScope": ["Advanced macro optimizations", "Complex inheritance scenarios", "Runtime default value extraction", "Custom default detection strategies"],
      "dependencies": ["T1"],
      "createdDate": "2025-07-12T00:00:00.000Z",
      "updatedDate": "2025-07-12T00:00:00.000Z"
    }
  ],
  "dependencies": [
    {
      "from": "T3",
      "to": ["T1", "T2"],
      "reason": "Map implementation needs default value fixes and examples serialization working"
    },
    {
      "from": "T4", 
      "to": ["T3"],
      "reason": "Set implementation should come after Map to follow complexity order"
    },
    {
      "from": "T5",
      "to": ["T4"], 
      "reason": "Vector implementation should come after Set as simplest collection"
    },
    {
      "from": "T6",
      "to": ["T1", "T2"],
      "reason": "Enum derivation needs foundation fixes completed first"
    },
    {
      "from": "T7",
      "to": ["T6"],
      "reason": "Sealed trait implementation must not break enum derivation"
    },
    {
      "from": "T8",
      "to": ["T7"],
      "reason": "Either implementation comes after ADT support is complete"
    },
    {
      "from": "T9",
      "to": ["T3", "T4", "T5"],
      "reason": "Collection tests require all collection implementations"
    },
    {
      "from": "T10",
      "to": ["T6", "T7"],
      "reason": "ADT tests require enum and sealed trait implementations"
    },
    {
      "from": "T11",
      "to": ["T8"],
      "reason": "Union type tests require Either implementation"
    },
    {
      "from": "T12",
      "to": ["T1"],
      "reason": "Enhanced default tests require fixed default value handling"
    },
    {
      "from": "T13",
      "to": ["T1", "T2", "T6", "T9", "T10", "T12"],
      "reason": "Final validation requires all critical implementations and tests complete"
    }
  ]
}