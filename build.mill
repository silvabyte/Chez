import mill._, scalalib._, publish._
import scala.util.{Try, Success, Failure}

case class GitHubDependency(
    owner: String,
    repo: String,
    modules: Option[Vector[String]] = Some(Vector.empty),
    version: String = "main"
)

//This lets me use gh repos directly for my deps
//and side step 3rd party package repos
trait GitHubDepsModule extends ScalaModule {
  def githubDeps: Seq[GitHubDependency] = Seq()

  def downloadAndBuildGitHubDeps = Task {
    val depsDir = Task.dest / "github-deps"
    os.makeDir.all(depsDir)

    githubDeps.flatMap { dep =>
      val repoDir = depsDir / s"${dep.owner}-${dep.repo}"

      // Clone or update repo
      if (!os.exists(repoDir)) {
        os.proc("git", "clone", s"https://github.com/${dep.owner}/${dep.repo}.git", repoDir).call()
      } else {
        os.proc("git", "fetch", "origin").call(cwd = repoDir)
      }

      // Checkout specific version
      os.proc("git", "checkout", dep.version).call(cwd = repoDir)

      // Build the project (assuming it uses Mill)
      if (os.exists(repoDir / "build.mill")) {
        // Use ./mill script if available, otherwise try system mill
        val millCmd = if (os.exists(repoDir / "mill")) "./mill" else "mill"

        Try {
          os.proc(millCmd, "__.assembly").call(cwd = repoDir)
        } match {
          case Success(_) =>
          case Failure(e) =>
            // Fallback: try individual module assemblies
            val modules = {
              os.proc(millCmd, "resolve", "_").call(cwd = repoDir).out.text().split('\n')
                .filter(_.nonEmpty).map(_.trim).toSeq
            }

            modules.find(!_.contains(".")).foreach { module =>
              os.proc(millCmd, s"$module.assembly").call(cwd = repoDir)
            }
        }

        // Find the generated JAR
        val outDir = repoDir / "out"
        val jarFiles = os.walk(outDir)
          .filter(_.ext == "jar")
          .filter(p => p.toString.contains("assembly.dest") && !p.toString.contains("test"))

        if (jarFiles.nonEmpty) {
          // Handle multiple modules: create separate JARs for each specified module
          dep.modules match {
            case Some(modules) if modules.nonEmpty =>
              // Find JAR files for each specified module
              modules.map { moduleName =>
                val moduleJarFiles =
                  jarFiles.filter(_.toString.contains(s"/$moduleName/assembly.dest"))
                if (moduleJarFiles.nonEmpty) {
                  val jarFile = moduleJarFiles.head
                  val targetJar =
                    Task.dest / s"${dep.owner}-${dep.repo}-$moduleName-${dep.version}.jar"
                  os.copy(jarFile, targetJar, replaceExisting = true)
                  PathRef(targetJar)
                } else {
                  throw new Exception(
                    s"No assembly JAR found for module $moduleName in ${dep.owner}/${dep.repo}"
                  )
                }
              }.toSeq
            case _ =>
              // No specific modules, use first available JAR
              val jarFile = jarFiles.head
              val targetJar = Task.dest / s"${dep.owner}-${dep.repo}-${dep.version}.jar"
              os.copy(jarFile, targetJar, replaceExisting = true)
              Seq(PathRef(targetJar))
          }
        } else {
          throw new Exception(s"No assembly JAR found for ${dep.owner}/${dep.repo}")
        }
      } else {
        throw new Exception(s"No build.mill found in ${dep.owner}/${dep.repo}")
      }
    }
  }

  override def unmanagedClasspath = Task {
    super.unmanagedClasspath() ++ downloadAndBuildGitHubDeps()
  }
}

trait PublishSettings extends SonatypeCentralPublishModule {

  def publishVersion = Task.Input {
    val packageJsonPath = os.pwd / os.up / os.up / os.up / "package.json"
    val packageJson = os.read(packageJsonPath)
    val json = upickle.default.read[ujson.Value](packageJson)
    json.obj("version").str
  }
}

trait Shared extends GitHubDepsModule with PublishSettings {
  def scalaVersion = "3.7.2"

  // Suppress the "caps" warning which is a known Scala 3 issue
  // This warning occurs because Scala 3 depends on Scala 2.13 stdlib for compatibility
  def scalacOptions = Seq(
    "-deprecation",
    "-feature",
    "-Wunused:all",
    "-Wconf:msg=package scala contains object and package with same name.*:s" // Suppress caps warning
  )

  // Add JVM options to suppress native access warnings
  def forkArgs = Seq(
    "--enable-native-access=ALL-UNNAMED" // Allow native access for file-tree-views library
  )

  def mvnDeps = Task {
    Seq(
      mvn"com.lihaoyi::upickle:4.1.0",
      mvn"com.lihaoyi::os-lib:0.11.3"
    )
  }

  override def githubDeps = Seq(
    GitHubDependency("silvabyte", "ScalaDotEnv", Some(Vector("DotEnv")), "v0.1.1")
  )

  object test extends ScalaTests {
    def mvnDeps = Task {
      Seq(
        mvn"com.lihaoyi::utest:0.8.5",
        mvn"org.scalamock::scalamock:7.1.0",
        mvn"org.scalatest::scalatest:3.2.19",
        mvn"com.lihaoyi::requests:0.9.0"
      )
    }
    def testFramework = "utest.runner.Framework"

    // Inherit fork arguments for tests as well
    override def forkArgs = super.forkArgs
  }

// Scalafix tasks
  def fix() = Task.Command {
    val sources = allSources().map(_.path)
    val sourceFiles = sources.flatMap(os.walk(_).filter(_.ext == "scala"))
    val configPath = (os.pwd / os.up / os.up / os.up / ".scalafix.conf").toString

    if (sourceFiles.nonEmpty) {
      os.proc(
        "cs",
        "launch",
        "scalafix",
        "--",
        "--config",
        configPath,
        "--scala-version",
        "3.7.2",
        "--syntactic",
        sourceFiles.map(_.toString)
      ).call()
    }
  }

  def fixCheck() = Task.Command {
    val sources = allSources().map(_.path)
    val sourceFiles = sources.flatMap(os.walk(_).filter(_.ext == "scala"))
    val configPath = (os.pwd / os.up / os.up / os.up / ".scalafix.conf").toString

    if (sourceFiles.nonEmpty) {
      os.proc(
        "cs",
        "launch",
        "scalafix",
        "--",
        "--config",
        configPath,
        "--scala-version",
        "3.7.2",
        "--syntactic",
        "--check",
        sourceFiles.map(_.toString)
      ).call()
    }
  }
}

object Schema extends Shared {
  override def artifactName = "schema"

  override def mvnDeps = Task {
    super.mvnDeps() ++ Seq()
  }

  override def pomSettings = PomSettings(
    description = "BoogieLoops Schema - Type-safe JSON Schema library for Scala 3",
    organization = "dev.boogieloops",
    url = "https://github.com/silvabyte/BoogieLoops",
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github("silvabyte", "BoogieLoops"),
    developers = Seq(
      Developer("matsilva", "Mat Silva", "https://github.com/matsilva")
    )
  )
}

object Web extends Shared {
  override def artifactName = "web"
  override def moduleDeps: Seq[Shared] = Seq(Schema)
  override def mvnDeps = Task {
    super.mvnDeps() ++ Seq(
      mvn"com.lihaoyi::cask:0.9.7",
      mvn"com.lihaoyi::scalatags:0.13.1",
      mvn"com.lihaoyi::os-lib:0.10.1"
    )
  }

  override def pomSettings = PomSettings(
    description = "BoogieLoops Web - HTTP API framework with automatic validation using BoogieLoops schemas",
    organization = "dev.boogieloops",
    url = "https://github.com/silvabyte/BoogieLoops",
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github("silvabyte", "BoogieLoops"),
    developers = Seq(
      Developer("matsilva", "Mat Silva", "https://github.com/matsilva")
    )
  )
}

object AI extends Shared {
  override def artifactName = "ai"
  override def moduleDeps: Seq[Shared] = Seq(Schema)
  override def mvnDeps = Task {
    super.mvnDeps() ++ Seq(
      mvn"com.outr::scribe:3.6.6",
      mvn"com.lihaoyi::requests:0.9.0"
    )
  }

  override def pomSettings = PomSettings(
    description = "BoogieLoops AI - LLM agent framework using BoogieLoops schemas",
    organization = "dev.boogieloops",
    url = "https://github.com/silvabyte/BoogieLoops",
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github("silvabyte", "BoogieLoops"),
    developers = Seq(
      Developer("matsilva", "Mat Silva", "https://github.com/matsilva")
    )
  )
}
